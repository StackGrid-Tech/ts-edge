"use strict";var _=Object.defineProperty;var Ee=Object.getOwnPropertyDescriptor;var Ne=Object.getOwnPropertyNames;var ye=Object.prototype.hasOwnProperty;var Ge=(t,e,r)=>e in t?_(t,e,{enumerable:!0,configurable:!0,writable:!0,value:r}):t[e]=r;var Te=(t,e)=>{for(var r in e)_(t,r,{get:e[r],enumerable:!0})},we=(t,e,r,n)=>{if(e&&typeof e=="object"||typeof e=="function")for(let o of Ne(e))!ye.call(t,o)&&o!==r&&_(t,o,{get:()=>e[o],enumerable:!(n=Ee(e,o))||n.enumerable});return t};var Se=t=>we(_({},"__esModule",{value:!0}),t);var R=(t,e,r)=>Ge(t,typeof e!="symbol"?e+"":e,r);var be={};Te(be,{GraphConfigurationError:()=>m,GraphDataError:()=>H,GraphError:()=>O,GraphErrorCode:()=>P,GraphExecutionError:()=>x,createGraph:()=>z,createStateGraph:()=>pe,graphMergeNode:()=>j,graphNode:()=>Z,graphNodeRouter:()=>ee,graphStateMergeNode:()=>re,graphStateNode:()=>te,graphStore:()=>he});module.exports=Se(be);var Z=t=>t;function ee(...t){return typeof t[0]=="function"?t[0]:{possibleTargets:t[0],router:t[1]}}var j=t=>t,te=t=>t,re=t=>j({branch:t.branch,name:t.name,metadata:t.metadata,execute:(e,r)=>t.execute(Object.values(e)[0],r)});var ne=t=>typeof t=="function",D=t=>ne(t?.then),ve=t=>{try{return t instanceof Error?t:typeof t=="string"?new Error(t):new Error(JSON.stringify(t))}catch(e){return e}},$=t=>({isOk:!0,error:void 0,value:t}),F=t=>({isOk:!1,error:ve(t),value:void 0}),Oe=(t,e)=>{if(D(t))return t.then(e).then($,F);try{let r=e(t);return D(r)?r.then(n=>Promise.resolve($(n)),n=>Promise.resolve(F(n))):$(r)}catch(r){return F(r)}},U={ok:$,fail:F,update:Oe},L=t=>{let e=r=>L(U.update(t,r));return{map(r){return e(n=>{if(n.isOk)return r(n.value);throw n.error})},flatMap(r){return e(n=>{if(n.isOk)return r(n.value).unwrap();throw n.error})},effect(r){return e(n=>{if(!n.isOk)throw n.error;let o=r(n.value);return D(o)?o.then(()=>n.value):n.value})},ifOk(r){return e(n=>{if(!n.isOk)throw n.error;let o=r(n.value);return D(o)?o.then(()=>n.value):n.value})},watch(r){return e(n=>{try{r({...n})}catch{}if(n.isOk)return n.value;throw n.error})},catch(r){return e(n=>n.isOk?n.value:r(n.error))},ifFail(r){return e(n=>n.isOk?n.value:r(n.error))},unwrap(){if(D(t))return t.then(r=>{if(r.isOk)return r.value;throw r.error});if(t.isOk)return t.value;throw t.error},isOk:D(t)?t.then(r=>Promise.resolve(r.isOk)):t.isOk,orElse(r){return e(n=>n.isOk?n.value:r).unwrap()}}};function oe(t){let e=L(U.ok(void 0));try{return e.map(()=>t)}catch(r){return e.map(()=>{throw r})}}function Ie(t){let e=L(U.ok(void 0));try{return e.map(()=>t())}catch(r){return e.map(()=>{throw r})}}function Re(){return L(U.ok(void 0))}function De(...t){return e=>{let r=oe(e);return t.reduce((n,o)=>n.map(o),r)}}function N(t){return t===void 0?Re():ne(t)?Ie(t):oe(t)}N.pipe=De;var C=t=>t==null,M=()=>"dume_xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,function(t){let e=Math.random()*16|0;return(t==="x"?e:e&3|8).toString(16)}),ae=(t,e,r)=>{let n;return new Promise((o,a)=>{n=setTimeout(async()=>{let i=r;typeof r=="function"&&(i=await N(r).ifFail(s=>s).unwrap()),a(i??new Error(`Execution aborted: Timeout of ${e}ms exceeded`))},e),t.then(i=>o(i),i=>a(i))}).finally(()=>{clearTimeout(n)})},se=()=>{let t=[];return{publish(e){t.forEach(async r=>r(e))},subscribe(e){t.push(e)},unsubscribe(e){let r=t.findIndex(n=>n===e);r!==-1&&t.splice(r,1)}}},ie=()=>{let t,e;return{promise:new Promise((n,o)=>{t=n,e=o}),reject:e,resolve:t}};var V=()=>{let t=Promise.resolve();return e=>(t=t.then(()=>e()),t)};var P=(c=>(c.INVALID_NODE_NAME="Node name cannot be empty or is invalid",c.DUPLICATE_NODE_NAME="Node with this name already exists in the graph",c.NODE_NOT_FOUND="Node not found in the graph",c.CIRCULAR_DEPENDENCY="Circular dependency detected in graph",c.INVALID_EDGE="Invalid edge configuration",c.MISSING_SOURCE_NODE="Source node not found for edge",c.DUPLICATE_EDGE="Node already has an outgoing connection",c.MERGE_NODE_MISSING_BRANCH="Merge node references non-existent source nodes",c.MAX_NODE_VISITS_EXCEEDED="Maximum node visits exceeded",c.EXECUTION_TIMEOUT="Graph execution timed out",c.NODE_EXECUTION_FAILED="Node execution failed",c.INVALID_DYNAMIC_EDGE_RESULT="Invalid result from dynamic edge router",c.THREAD_POOL_FAILURE="Thread pool execution failed",c.EXECUTION_ABORTED="Graph execution was aborted",c.MIDDLEWARE_FAIL="Error thrown in graph middleware",c.EXIT="EXIT",c.INVALID_INPUT="Invalid input data provided",c.INVALID_OUTPUT="Node produced invalid output data",c.TYPE_MISMATCH="Data type mismatch between nodes",c.UNKNOWN_ERROR="Unknown error occurred in graph execution",c))(P||{}),O=class extends Error{constructor(r,n){let o=n?.message||r;super(o);R(this,"code");R(this,"nodeName");R(this,"context");R(this,"cause");this.code=r,this.nodeName=n?.nodeName,this.context=n?.context,this.cause=n?.cause,this.name="GraphError"}toString(){let r=`[${this.name}] ${this.message}`;return this.nodeName&&(r+=`
Node: ${this.nodeName}`),this.context&&Object.keys(this.context).length>0&&(r+=`
Context: ${JSON.stringify(this.context,null,2)}`),this.cause&&(r+=`
Caused by: ${this.cause}`),r}formatWithNode(r){if(!r&&!this.nodeName)return this.message;let n=r||this.nodeName;return`${this.message} (Node: ${n})`}},m=class t extends O{constructor(e,r){super(e,r),this.name="GraphConfigurationError"}static nodeNotFound(e){return new t("Node not found in the graph",{message:`Node "${e}" not found in the graph`,nodeName:e})}static duplicateNode(e){return new t("Node with this name already exists in the graph",{message:`Node with name "${e}" already exists in the graph`,nodeName:e})}static duplicateEdge(e){return new t("Node already has an outgoing connection",{message:`Node "${e}" already has an outgoing connection`,nodeName:e})}static invalidMergeBranch(e,r){return new t("Merge node references non-existent source nodes",{message:`Merge node "${e}" references non-existent source node(s): ${r.join(", ")}`,nodeName:e,context:{missingBranch:r}})}},x=class t extends O{constructor(e,r){super(e,r),this.name="GraphExecutionError"}static nodeExecutionFailed(e,r,n){return new t("Node execution failed",{message:`Execution of node "${e}" failed: ${r.message}`,nodeName:e,cause:r,context:n?{input:n}:void 0})}static timeout(e){return new t("Graph execution timed out",{message:`Graph execution timed out after ${e}ms`,context:{timeoutMs:e}})}static maxVisitsExceeded(e,r){return new t("Maximum node visits exceeded",{message:`Maximum node visits (${r}) exceeded for node "${e}"`,nodeName:e,context:{maxVisits:r}})}static invalidDynamicEdgeResult(e,r){return new t("Invalid result from dynamic edge router",{message:`Node "${e}" returned invalid dynamic edge result`,nodeName:e,context:{result:r}})}},H=class t extends O{constructor(e,r){super(e,r),this.name="GraphDataError"}static invalidInput(e,r,n){return new t("Invalid input data provided",{message:`Invalid input for node "${e}": ${r}`,nodeName:e,context:n?{input:n}:void 0})}static invalidOutput(e,r,n){return new t("Node produced invalid output data",{message:`Invalid output from node "${e}": ${r}`,nodeName:e,context:n?{output:n}:void 0})}static typeMismatch(e,r,n){return new t("Data type mismatch between nodes",{message:`Type mismatch between nodes "${e}" and "${r}": ${n}`,context:{sourceNode:e,targetNode:r}})}};var ue=({executionId:t,name:e,node:r,end:n,baseBranch:o,threadId:a,recordExecution:i,publishEvent:s})=>async h=>{let g=Date.now(),l=M();return N(r).watch(s.bind(null,{nodeExecutionId:l,executionId:t,threadId:a,eventType:"NODE_START",startedAt:g,node:{name:e,input:h}})).ifOk(u=>{if(!u)throw x.nodeExecutionFailed(e,new Error(`Node not found: "${e}"`),h)}).map(u=>{let E={stream:w=>s({eventType:"NODE_STREAM",nodeExecutionId:l,executionId:t,threadId:a,timestamp:Date.now(),node:{name:e,chunk:w}}),metadata:u.metadata??{}};return u.execute(h,E)}).map(async u=>{if(!C(n)&&e==n||!r.edge)return{name:[],output:u,exit:!0};if(r.edge.type=="direct")return{output:u,name:r.edge.next};let E=r.edge.router,I=[await E(u)].flat().filter(A=>{if(C(A))return!1;if(typeof A!="string")throw x.invalidDynamicEdgeResult(e,I);return!0});return{name:I,output:u}}).map(u=>!u.name.length&&o.length&&!u.exit?{name:o,output:u.output}:u).watch(u=>{let E={startedAt:g,endedAt:Date.now(),threadId:a,error:u.error,nodeExecutionId:l,node:{input:h,name:e,output:u.value?.output},isOk:u.isOk};i(E),s({eventType:"NODE_END",executionId:t,...E})}).unwrap()};var de=()=>{let t=new Map,e={error:void 0,...ie()},r=()=>{for(let a of t.values())if(a.tasks.some(i=>!i.isCompleted))return!1;return!0},n=(a,i)=>{let s=t.get(a);if(!s)return;let h=s.tasks.findIndex(g=>g.promise===i);h!==-1&&(s.tasks[h].isCompleted=!0)},o=a=>{r()&&(e.error?e.reject(e.error):e.resolve(a))};return{waitForCompletion(){return e.promise},scheduleTask(a,i){if(e.error)return;t.has(a)||t.set(a,{chain:V(),tasks:[]});let s=t.get(a),h=s.chain(async()=>{try{let g=await Promise.resolve().then(()=>i());return n(a,h),o(g),g}catch(g){throw n(a,h),e.error||(e.error=g),o(),e.error}});s.tasks.push({promise:h,isCompleted:!1})},abort(a="Thread pool execution aborted"){e.error=new Error(a),e.reject(e.error)}}};var ce=({start:t,end:e,registry:r})=>{let{publish:n,subscribe:o,unsubscribe:a}=se(),i=[],s=[],h,g={isRunning:()=>s.length>0,subscribe:o,unsubscribe:a,publish:n,exit(l){s.length&&(h=N(()=>String(l)||"").ifFail(u=>u?.name||"stop-error").unwrap())},use(l){return i.push(l),g},getStructure(){return Array.from(r.entries()).map(([l,u])=>({name:l,metadata:u.metadata,isMergeNode:u.isMergeNode,edge:u.edge?{name:u.edge.next,type:u.edge.type}:void 0}))},async run(l,u){let E={timeout:6e5,maxNodeVisits:100,disableHistory:!1,...u};h=void 0;let w=M();s.push(w);let I=Date.now(),A=Array.from(r.entries()).reduce((d,[f,y])=>(y.branch?.forEach(p=>{d[p]??(d[p]=[]),d[p].push(f)}),d),{}),b=[],le=d=>{E.disableHistory||b.push(d)},ge=(d,f,y)=>{let p=Y.get(d),S=p.find(T=>T.source===f);return S.pending=!1,S.output=y,p.some(T=>T.pending)?null:p.reduce((T,k)=>(T[k.source]=k.output,T),{})},Y=Array.from(r.entries()).reduce((d,[f,y])=>(y.isMergeNode&&d.set(f,y.branch.map(p=>({source:p,output:void 0,pending:!0}))),d),new Map),c=de(),W=(d,f,y)=>{c.scheduleTask(d,async()=>{let p=f,S=y,J=V();await Promise.all(i.map(v=>J(async()=>{try{await v({name:p,input:S},B=>{B&&(p=B.name,S=B.input)})}catch(G){throw new x("Error thrown in graph middleware",{message:`Middleware error for node "${p}": ${G instanceof Error?G.message:String(G)}`,nodeName:p,cause:G instanceof Error?G:new Error(String(G)),context:{input:S}})}})));let T=r.get(p);if(!T)throw x.nodeExecutionFailed(p,new Error(`Node not found: "${p}"`),S);if(E.maxNodeVisits--<=0)throw x.maxVisitsExceeded(p,u?.maxNodeVisits||100);let k=ue({executionId:w,name:p,end:e,baseBranch:A[p]??[],threadId:d,node:T,recordExecution:le,publishEvent:n}),{name:Q,output:X}=await k(S),xe=[...Q.map(()=>M()),d],q=()=>xe.pop();return Q.forEach(async v=>{if(!Y.has(v))return W(q(),v,X);let G=ge(v,p,X);if(G)return W(q(),v,G)}),X})},me=()=>{n({eventType:"WORKFLOW_START",executionId:w,startedAt:I,input:l})},fe=d=>{n({eventType:"WORKFLOW_END",executionId:w,startedAt:I,endedAt:Date.now(),histories:b,isOk:d.isOk,error:d.error,output:d.value})},K=d=>f=>{if(e&&b.at(-1)?.node.name!=e){let y=[...b].reverse().find(p=>p.node.name==e)?.node;y&&(f=y.output)}return{startedAt:I,endedAt:Date.now(),histories:b,error:d?void 0:f instanceof Error?f:new Error(String(f)),output:d?f:void 0,isOk:d}};return N().map(()=>ae(N().watch(me).map(W.bind(null,M(),t,l)).map(c.waitForCompletion).watch(fe).unwrap(),Math.max(0,E.timeout),()=>{let d=x.timeout(E.timeout);return c.abort(d.message),d})).map(K(!0)).ifFail(K(!1)).watch(()=>{s=s.filter(d=>d!=w)}).unwrap()}};return g.use(l=>{if(h!=null)throw new x("EXIT",{message:h||"Exit",nodeName:l.name})}),g};var z=()=>{let t=new Map,e=()=>{Array.from(t.entries()).forEach(([n,o])=>{if(o.isMergeNode){let a=o.branch.filter(i=>!t.has(i));if(a.length>0)throw m.invalidMergeBranch(n,a);o.branch.forEach(i=>{let s=t.get(i);if(s&&s.edge?.type!="dynamic"){let h={type:"direct",next:Array.from(new Set([...s.edge?.next??[],n]))};s.edge=h}})}else if(o.edge?.type==="direct"){let a=o.edge.next.filter(i=>!t.has(i));if(a.length>0)throw new m("Source node not found for edge",{message:`Node "${n}" has direct edge to non-existent node(s): ${a.join(", ")}`,nodeName:n,context:{invalidTargets:a}})}})},r={addNode({name:n,execute:o,metadata:a}){if(t.has(n))throw m.duplicateNode(n);return t.set(n,{execute:o,isMergeNode:!1,metadata:a??{}}),r},addMergeNode({branch:n,execute:o,name:a,metadata:i}){if(t.has(a))throw m.duplicateNode(a);return t.set(a,{execute:o,isMergeNode:!0,branch:n,metadata:i??{}}),r},edge(n,o){let a=t.get(n);if(!a)throw m.nodeNotFound(n);if(a.edge)throw m.duplicateEdge(n);return a.edge={type:"direct",next:[o].flat()},r},dynamicEdge(n,o){let a=t.get(n);if(!a)throw m.nodeNotFound(n);if(a.edge)throw m.duplicateEdge(n);return a.edge={type:"dynamic",next:typeof o=="function"?[]:o.possibleTargets,router:typeof o=="function"?o:o.router},r},compile(n,o){if(!t.has(n))throw m.nodeNotFound(n);if(o&&!t.has(o))throw m.nodeNotFound(o);return e(),ce({start:n,end:o,registry:t})}};return r},pe=t=>{let e=z(),r=e.addNode,n=e.addMergeNode,o=e.compile;return e.addNode=a=>(r({...a,execute:(i,s)=>N(()=>a.execute(t.get(),s)).map(()=>t.get()).unwrap()}),e),e.addMergeNode=a=>(n({...a,execute:(i,s)=>N(()=>a.execute(i,s)).map(()=>t.get()).unwrap()}),e),e.compile=(a,i)=>{let s=o(a,i),h=s.run;return s.run=(g,l)=>(l?.noResetState||t.reset(),C(g)||t.set(g),h(void 0,l)),s},e};var Me=(t,e)=>{let r=typeof e!="function"?e:e(t);return Object.assign(t??{},r)},he=t=>{let e,r=()=>e,n=a=>{e=Me(e,a)};e=t(n,r);let o={...e};return r.get=r,r.set=n,r.reset=()=>n({...o}),r};0&&(module.exports={GraphConfigurationError,GraphDataError,GraphError,GraphErrorCode,GraphExecutionError,createGraph,createStateGraph,graphMergeNode,graphNode,graphNodeRouter,graphStateMergeNode,graphStateNode,graphStore});
